\documentclass[12pt,a4paper]{article}
\input{Preamble/packages}
\input{Preamble/commands}
\addbibresource{ref.bib}

% "package" for complexity lines
\input{Preamble/comp_line.tex}

\begin{document}

\section{Definitions}
% General note: I wrote this all out as an exercise in getting my definitions straight, it
% does not need to be THIS detailed.

\subsection{Notation}
We will use $\delta(v)$ to refer to the set of edges adjacent to $v$. We identify
half-edges in a graph $G=(V,E)$ with a pair $(e,v)$ where $e\in\delta(v)$, referring to
the half of $e$ adjacent to $v$.

We use $\MSet{\star}$ to refer to multisets, and the following notation for multisubsets
of a set $A$:
\begin{itemize}
    \item $A^{\MSet{k}}$ refers to the set of all multisubsets of $A$ of size $k\in\N$,
    \item $A^{\MSet{\N}}$ refers to the set of all finite multisubsets of $A$,
    \item $A^{\MSet{\star}}$ refers to the set of all multisubsets of $A$,
\end{itemize}
\subsection{Common and uncommon assumptions}
%\airquotes{Unless otherwise \emph{explicitly} stated...}
\textbf{$T$-hop neighbourhoods:} we define a \emph{$T$-hop centered neighbourhood} as a
\emph{centered graph of radius $T$} using the definitions from page 4 of
\cite{naor_what_1993}. Note that, in the case of subgraphs, the $T$-hop neighbourhood of
$v$ may be different from the subgraph induced by all nodes that have distance at most $T$
from $v$.

\textbf{Local model:} we work in the \emph{deterministic} LOCAL model with input labels.
No assumptions are made about the number of input or output labels. We assume the nodes
are aware of the exact number $n$ of nodes in the input graph, but not of any information
about the maximum degree $\Delta$. Because of this information, we equivalently describe a
LOCAL algorithm as a $T(n)$-round communication algorithm with unbounded message size, or
as a \emph{possibly uncomputable} function from $T(n)$-hop centered neighbourhoods to
output labels. Additionally, we assume there is a finite integer $c$ such that every node
is assigned a unique ID in the set $\Set{1,\ldots,n^c}$, but the nodes are not aware of
the value of $c$.

\textbf{Solvability:} we say that a problem is \emph{weakly solvable} if there are
finitely many unsolvable instances for it (this includes problems that are always
solvable). We can, and often will, treat weakly solvable problems as solvable problems by 
implictly adding one output label $U$ and requiring the problem to output $U$
on all nodes if the instance is unsolvable; this requires only constant time, so it does
not affect asymptotic complexity. We say that a problem is
\emph{strongly unsolvable} if there are infinitely many unsolvable instances for it. We
call the maximum diameter of an unsolvable instance the \emph{solvability horizon} of a
weakly solvable problem; if the problem is always solvable, we define it as 0, and if it
is strongly unsolvable, we define it as $\infty$.
%note: some further nuance could be given for "infinitely many solvable and unsolvable
%instances" eg, 2 colouring on cycles, but it is not relevant to the work I want to put in
%here. similarly, "verifiably unsolvable" for infinitely many unsolvable instances that
%can be checked in constant time by every node, but I still have no examples of this (I
%think there are none in LCLs but could be wrong).

\textbf{LCL problems:} we define LCL problems as tuples
$\Pi=(\Delta,\Sigma\uin,\Sigma\uout,r,\Cc)$ where:
\begin{itemize}
    \item $\Delta$ is a natural number, representing the maximum degree of the graph class considered,
    \item $\Sigma\uin$ is a set of input labels,
    \item $\Sigma\uout$ is a set of output labels,
    \item $r$ is a finite integer, called the \emph{radius} of $\Pi$, and
    \item $\Cc$ is a \emph{finite} set of $r$-hop centered neighbourhoods of
    maximum degree $\Delta$, where each node is labelled by a pair in 
    $\Sigma\uin\times\Sigma\uout$.
\end{itemize}
Though we haven't explicitly stated this in the definition, WLOG we can and will also
assume that $\Sigma\uin$ is finite (else the problem would be trivially strongly unsolvable, since
only finitely many input labels appear in $\Cc$) and that $\Sigma\uout$ is finite
(any labels that don't appear in $\Cc$ will not appear in any valid solution and can be ignored).
%instance and solution as usual.

\textbf{Node-edge checkable problems:}
we define node-edge checkable problems as tuples 
$\Pi=(\Delta,\Sigma\uin,\Sigma\uout,\Nc,\Ec)$ where:
\begin{itemize}
    \item $\Delta$ is a natural number, representing the maximum degree of the graph class considered,
    \item $\Sigma\uin$ is a set of input labels,
    \item $\Sigma\uout$ is a set of output labels,
    \item $r$ is a finite integer, called the \emph{radius} of $\Pi$, and
    \item $\Nc$ is an indexed set $\Set{\Nc_{d,\chi}}_{d\leq\Delta,\chi\in\Sigma\uin}$
    where each $\Nc_{d,\chi}$ is a subset of $\Sigma\uout^{\MSet{d}}$ (representing the
    set of allowed configurations for a node of degree $d$ with input label $\chi$),
    \item $\Ec$ is a subset of $\Sigma\uout^{\MSet{2}}$ (representing the set of allowed
    configurations over edges).
\end{itemize}
Similar reasoning to the above as to why we can implictly assume that $\Sigma\uin$ and
$\Sigma\uout$ are finite sets. 


\subsection{New-ish definitions}
%these are definitions that have appeared before (cited) but are not "commonly used" as
%far as I could tell or are natural variants of common definitions
\textbf{Hanging trees:} \emph{connected} tree graphs containing a finite number of
incomplete half-edges, called \emph{hooks}. Specifically, we will call hanging trees with
one hook \emph{ornaments} and hanging trees with two hooks \emph{tinsels}. We call nodes
adjacent to one or more hooks \emph{hinge nodes}.
% I'm using christmasy terms for things because they make a nice and intuitive visual, but
% also because "hanging trees" could have... a different connotation.

\textbf{Hanging tree sets:} we define as $\Tc_{k,\Delta}$ the set of all hanging trees
with $k$ hooks and maximum degree $\Delta$. Additionally, we define
$\Tc_k=\bigcup_{\Delta\in\N}\Tc_{k,\Delta}$ as the set of all hanging trees with $k$
hooks. Note that both are countably infinite sets.

\textbf{Class:} given an ornament $T$ and a node-edge checkable problem or FSL problem $\Pi$, we define 
the \emph{class} of $T$ to be the set $\frCl(T)\subseteq \Sigma\uout$ containing
exactly the labellings of the hook that can be completed to a valid labelling for $T$
according to $\Pi$. Up to the changed role of nodes and edges, this is the \emph{class}
definition from Section 3 of \cite{chang_time_2017}. Note that since $\Sigma\uout$ is
finite, so is the set of all possible classes.
%I have been calling them types, but chang-pettie calls them classes and uses types for
%paths... I'm trying to stick to classes but there might be mistakes TODO classes for
%ornaments/general hanging trees. Mostly concerned about keeping track of which label goes
%where in a nice way. Leaving it for if I try to generalise the proof for non-trees.

\textbf{Equivalent problems in LOCAL:} we say that two LOCAL problems $\Pi_A$, $\Pi_B$
have the same asymptotic locality/are equivalent if both apply:
\begin{itemize}
    \item if there is an algorithm solving $\Pi_A$ in $T_A(n)$ rounds, there
    is an algorithm solving $\Pi_B$ in $\Theta(T_A(n))$ rounds, and
    \item if there is an algorithm solving $\Pi_B$ in $T_B(n)$ rounds, there
    is an algorithm solving $\Pi_A$ in $\Theta(T_B(n))$ rounds.
\end{itemize}
%this is a weaker definition than the one I gave in the binary labelling work, which
%required a constant-locality reduction from \Pi_A to \Pi_B

\textbf{LOCAL hierarchy of problem classes:} let $\Ac,\mathcal{B}$ be classes of
LOCAL problems. We say that $\Ac\into \mathcal{B}$ if there exists an injective function
$\tau:\Ac\to\mathcal{B}$ such that $\forall \Pi_A\in\Ac\ \Pi_A$ has the
same asymptotic locality as $\tau(\Pi_A)$.

\textbf{LOCAL equivalence of problem classes:} let $\Ac,\mathcal{B}$ be classes of
LOCAL problems. We say that $\Ac$ is equivalent to $\mathcal{B}$ (denoted
$\Ac\cong \mathcal{B}$) if $\Ac\into \mathcal{B}$ and $\mathcal{B}\into\Ac$.
%the injectivity is a debatable part; depending on whether one wants some real
%correspondence between the classes or simply the same complexity classes

\subsection{Actually new definitions}
%There's some discussion I want to make about writing the def below in "round eliminator
% formalism", but for now it's closer to node-edge checkable the "Extended" is the more
% formally complicated but intuitive definition; the normal FSL definition is formally
% simpler, just as powerful, but not as easy to understand
\textbf{Finitely Represented Configuration:} given an alphabet of symbols $\Sigma$, we
call a \emph{finitely represented configuration} of $\Sigma$ a pair of a \emph{finite}
multisubset of $\Sigma$ (the \emph{requirement}) and a \emph{finite} subset of $\Sigma$
(the \emph{filler}). We denote the set of finitely represented configurations in $\Sigma$
as 
$$\Sigma^{FSL}:=\Sigma^{\MSet{\N}}\times \left[\Sigma\right]^{<\omega}$$

\textbf{Extended Finite State Labelling problems:} we define Extended FSL problems as
tuples $\Pi=(\Sigma\uin,\Sigma\uout,f,\Nc,\Ec)$ where:
\begin{itemize}
    \item $\Sigma\uin$ is a \emph{finite} set of input labels,
    \item $\Sigma\uout$ is a \emph{finite} set of output labels,
    \item $f:\N\to2^{\Sigma\uin}$ is a \emph{computable} function describing which input labels are allowed
    to appear for a node of degree $d\in\N$ which is surjective on some cover of
    $\Sigma\uin$ (in other words, each label in $\Sigma\uin$ appears in some set in $f(\N)$),
    \item $\Nc:\Sigma\uin\to 2^{(\Sigma\uout)^{FSL}}$ is a function assigning to each
    input label a set of \emph{finitely represented configurations} of $\Sigma\uout$, and 
    \item $\Ec$ is a set of pairs of elements of $\Sigma\uout$.
\end{itemize}
An \emph{instance} for $\Pi$ is a graph $G=(V,E)$ together with a labelling function
$l:V\to\Sigma\uin$ such that $l(v)\in f(\deg(v))$, that is, the labelling is coherent with
the \airquotes{allowed} labels for each degree.\\
A \emph{solution} for this instance is a labelling $s$ of the half-edges of $G$ such that:
\begin{itemize}
    \item $\forall v\in V$, let $S(v):=\MSet{s(e,v)\dv e\in\delta(v)}$; then there exists
    $(R,F)\in\Nc(l(v))$ such that $R\subseteq S(v)$ and $(S(v)\smallsetminus R)\subseteq
    F^{\MSet{\star}}$, that is to say, every symbol in the requirement appears exactly
    once in $S(v)$, and every other symbol of $S(v)$ is a filler symbol, and 
    \item $\forall e=\Set{u,v}\in E$ we have $\Set{s(e,u),s(e,v)}\in\Ec$.
\end{itemize}

\textbf{Finite State Labelling problems:} we define FSL problems as tuples
$\Pi=(\Sigma\uout,\Nc,\Ec)$ where:
\begin{itemize}
    \item $\Sigma\uout$ is a \emph{finite} set of output labels,
    \item $\Nc\subseteq 2^{(\Sigma\uout)^{FSL}}$ is a \emph{finite} set of finitely
    represented configurations of $\Sigma\uout$, and
    \item $\Ec$ is a set of pairs of elements of $\Sigma\uout$.
\end{itemize}
An \emph{instance} for $\Pi$ is any graph; a solution for this instance is a labelling $s$
of the half-edges of $G$ such that:
\begin{itemize}
    \item $\forall v\in V$, let $S(v):=\MSet{s(e,v)\dv e\in\delta(v)}$; then there exists
    $(R,F)\in\Nc$ such that $R\subseteq S(v)$ and $(S(v)\smallsetminus R)\subseteq
    F^{\MSet{\star}}$, that is to say, every symbol in the requirement appears exactly
    once in $S(v)$, and every other symbol of $S(v)$ is a filler symbol, and 
    \item $\forall e=\Set{u,v}\in E$ we have $\MSet{s(e,u),s(e,v)}\in\Ec$.
\end{itemize}

\textbf{FSL problems with input:} we define I-FSL problems (Input-Finite State Labelling problems)
as tuples $\Pi=(\Sigma\uin,\Sigma\uout,\Nc,\Ec)$ where:
\begin{itemize}
    \item $\Sigma\uin$ is a \emph{finite} set of input labels,
    \item $\Sigma\uout$ is a \emph{finite} set of output labels,
    \item $\Nc:\Sigma\uin\to 2^{(\Sigma\uout)^{FSL}}$ is a function assigning to each
    input label a \emph{finite} set of finitely represented configurations of $\Sigma\uout$, and 
    \item $\Ec$ is a set of pairs of elements of $\Sigma\uout$.
\end{itemize}
We will prove that inputs do not make the class stronger, that is, FSL$\cong$I-FSL.

\textbf{Minimum degree of a label:} we define the \emph{minimum degree} of an input label
$\chi\in\Sigma\uin$ as $\deg_{\min}(\chi):=\min\Set{d\in\N\dv \chi\in f(d)}$ (the minimum
degree for which that input label is allowed). This set is never empty. Generally, we
can assume that $\forall (R,F)\in \Nc(\chi)$ we have $\card{R}=\deg_{\min}(\chi)$, since a
configuration with a longer requirement would be unattainable by a finite number of degrees (which can
be encoded by putting them in separate input classes) and any configuration with a shorter
requirement implicitly requires using a number of filler symbols, which can be encoded by
adding all combinations of filler symbols to the requirements multiset.

\textbf{Width:} we define the \emph{width} of a EFSL problem $\Pi$ as the maximum length of one
of its requirements: accounting for hidden requirements encoded in the degree, we get
$$\max\Set{\max_{\chi\in\Sigma\uin}\deg_{\min}(\chi),\max\Set{\card{R}\dv\exists\chi\in\Sigma\uin,\exists
F\subset \Sigma\uout:(R,F)\in\Nc(\chi)}} $$
For FSL problems we define it as
$\max\Set{\card{R}\dv\exists F(\subset \Sigma\uout:R,F)\in\Nc}$.

\textbf{Height:} we define the \emph{height} of an EFSL problem as
$h(\Pi):=\max\Set{\card{\Nc(\chi)}\dv\chi\in\Sigma\uin}$ (the maximum number of configurations any
node can be in). For FSL problems we define it as $\card{\Nc}$.

\section{List of results}
\begin{enumerate}
    \item FSL $\into$ EFSL, but EFSL$\not\into$FSL as it cannot encode the function $f$. 
    \item I-FSL $\cong$ FSL.
    \item Node-edge checkable problems $\into$ FSL (obvious-ish: add configurations so the
    nodes of deg $>\Delta$ are unconstrained).
    \item Weak and strong solvability are decidable on FSL.
\end{enumerate}
\section{List of possible results}
\begin{enumerate}
    \item If a FSL problem is known to be $\Omega(\log n)$ on trees, its complexity on
    trees is decidable and an efficient algorithm can be found.
    \item (Belief I haven't been able to fully prove) For each FSL problem $\Pi$ there is
    a value $d$ that only depends on the problem description (specifically, number of
    labels, height and width) such that there is a worst-case family of graphs for $\Pi$
    of maximum degree $d$. My theory is either width$+1$ or width$\cdot$height (also
    possible: width+height, using one of each filler). Latter is
    required for solvability.
    \item (Investigating) A form of the Round Elimination procedure applies to FSL.
    problems.
\end{enumerate}


\section{Proofs} 
\subsection{Old(er) proofs that I finally formalised}
\subsubsection{Equivalence of FSL and I-FSL}
\begin{thm}
    FSL $\cong$ I-FSL.
\end{thm}
\begin{proof}
    FSL $\into$ I-FSL is trivial: we can interpret a FSL problem as a I-FSL problem with a
    single input label. We show that I-FSL $\into$ FSL; let
    $\Pi=(\Sigma\uin,\Sigma\uout,\Nc,\Ec)$ be a I-FSL. WLOG (up to renaming) we assume
    that $\Sigma\uin=\Set{1,\ldots,\card{\Sigma\uin}}$, then we define
    $\tau(\Pi)=(\Sigma\uout',\Nc',\Ec')$:
    \begin{itemize}
        \item We extend $\Sigma\uout$ by a leaf label $I_L$, a path label $I_P$, labels $I_i$ indexed by the
        input labels, and an input error label $I_E$; formally,
        $$\Sigma\uout'=\Sigma\uout\cup\Set{I_L,I_E,I_P}\cup\Set{I_i\dv i\in\Sigma\uin}$$
        \item We define $\Nc'$ step by step:
        \begin{enumerate}
            \item We initialise it as the disjoint union of the sets $\Nc(i)$ for
            $i\in\Sigma\uin$ indexed by an extra constraint $I_i$: formally,
            $$\Nc'_1=\Set{(\MSet{I_i}\cup R,F)\dv i\in\Sigma\uin, (R,F)\in \Nc(i)}$$
            \item We force the configurations in $\Nc'_1$ to only apply to nodes of degree
            $\geq 3$ by appending leaf labels $I_L$ to the requirement until it is of
            length $\geq 3$ and adding $I_L$ to the possible filler labels: formally,
            $$\Nc'_2=\Set{\phantom{\Big|}\!\!\!(R\cup L,F\cup\MSet{I_L})\!\dv\! (R,F)\in\Nc'_1,
            L=\MSet{I_L,\ldots,I_L}, \abs{L}=\max\Set{0,3-\abs{R}}\!} $$
            \item We use nodes of degree exactly 1 and 2 to encode input label $k$ as a hanging
            path of length $k+1$; hanging paths of length $\geq\abs{\Sigma\uin}+1$ are represented
            by the error input label $I_E$, isolated paths are represented by the path
            label $I_P$. Formally,
            \begin{align*}
                \Nc'_3=\Nc'_2&\cup\Set{(\MSet{I_L},\emptyset),(\MSet{I_L,I_P},\emptyset),(\MSet{I_P,I_P},\emptyset),(\MSet{I_L,I_1},\emptyset)}\\
                &\cup\Set{(\MSet{I_i,I_{i+1}},\emptyset)\dv i\in\Set{1,\ldots,\abs{\Sigma\uin}-1}}
            \end{align*}
            \item We allow nodes of degree $\geq 3$ who do not receive an input
            label to output anything: formally,
            $$\Nc'_4=\Nc'_3\cup\Set{(R,\Sigma\uout\cup\Set{I_L})\dv R\in
            (\Sigma\uout\cup\Set{I_L})^{\MSet{3}}}$$
            \item Similarly, we allow nodes of degree $\geq 3$ who receive an input error label
            $I_E$ to output anything: formally,
            $$\Nc'=\Nc'_4\cup\Set{\phantom{\Big|}\!\!\!(\MSet{I_E}\cup R,\Sigma\uout\cup\Set{I_L,I_E})\dv R\in
            (\Sigma\uout\cup\Set{I_L,I_E})^{\MSet{2}}}$$
        \end{enumerate}
        \item We extend $\Ec$ by symmetric pairs of labels added to $\Sigma\uout$; formally,
        $$\Ec'=\Ec\cup\Set{(I_E,I_E),(I_L,I_L)}\cup\Set{(I_i,I_i)\dv
        i\in\Set{1,\ldots,\abs{\Sigma\uin}}}$$
    \end{itemize}
    Now, we want to prove that $\Pi$ and $\tau(\Pi)$ have the same asymptotic locality;
    specifically, we will show that there is a constant-round reduction from $\Pi$ to
    $\tau(\Pi)$ and viceversa.

    $\Pi\to\tau(\Pi)$: assume we have an algorithm $\Ac$ to solve $\Pi$ in $T(n)$ rounds.
    Let $G$ be a graph

    $\tau(\Pi)\to\Pi$: 
\end{proof}
\subsubsection{Solvability}
We include definitions of B-hypergraph, B-hyperpath and hyperpath tree based on
\cite{thakurLinearConnectivityProblems2009} and \cite[Section 2]{ausielloOptimalTraversalDirected1997}
\begin{definition}{\cite[Definition 2.2]{thakurLinearConnectivityProblems2009}}
        A \emph{directed hypergraph} $H$ is a pair $(V , E)$, where V is a finite set and $E
        \subseteq 2^V \times 2^V$ such that, for every $e=(T(e),H(e))\in E,
        T(e)\neq\emptyset, H(e)\neq\emptyset$, and $T(e)\cap H(e)=\emptyset$. A
        B-hyperedge is a hyperedge e = (T (e), H(e)) such that $\card{H(e)} = 1$; a
        directed B-hypergraph is a directed hypergraph H such that each hyperedge in H is
        a B-hyperedge.
    \end{definition}
    \begin{definition}{\cite[Definition 2.4]{ausielloOptimalTraversalDirected1997}}
        Let $H=(V,E)$ be a directed B-hypergraph, let $X\subseteq V$ be a non-empty subset
        of nodes and $t$ be a node in $V$. There is a \emph{B-hyperpath} from $X$ to $t$ in $V$
        if $y\in X$, or there is an hyperedge $e=(Z,\Set{y})$ such that there is a
        B-hyperpath from $X$ to each $z_i\in Z$.
    \end{definition}
    \begin{definition}{\cite[Definition 2.5]{ausielloOptimalTraversalDirected1997}}
        Let $H=(V,E)$ be a directed B-hypergraph, let $X\subseteq V$ be a non-empty subset
        of nodes and $t$ be a node in $V$ such that there is a B-hyperpath from $X$ to
        $t$. A \emph{hyperpath tree} is a tree $T_{X,t}$ defined as follows:
        \begin{itemize}
            \item if $t\in X$, $T_{X,t}$ is the empty tree,
            \item if there is a hyperarc $e=(Z,t)$ and hyperpaths from $X$ to
            each $z_i\in Z$, then $T_{X,t}$ consists of a root labelled $e$ having as
            subtrees the hyperpath trees $T_{X,z_i}$ for each $z_i\in Z$.
        \end{itemize}
    \end{definition}

\begin{thm}
Let $\Pi$ be a node-edge checkable problem. Then it is possible to decide
whether $\Pi$ is strongly unsolvable or weakly solvable on trees and compute the 
solvability horizon. %in what time?
\end{thm}
\begin{proof}
    Let $\Pi=(\Delta,\Sigma\uin,\Sigma\uout,\Nc,\Ec)$, we construct the \emph{existential graph of classes} of $\Pi$,
    which is a directed B-hypergraph we denote with $H^{Cl}_{\Pi}$ and define as follows:
    \begin{itemize}
        \item the set of nodes of $H^{Cl}_{\Pi}$ is $\Pow(\Sigma\uout)$ with an extra node
        labelled $\bot$,
        \item there is an edge from $\Set{Cl_1,\ldots,Cl_k}$ to $Cl$ if and only if there is a hanging tree of class $Cl$ whose set of sub-hanging trees
            (meaning, the hanging trees obtained by removing the hook node and all of its
            adjacent half-edges) is exactly $\Set{Cl_1,\ldots,Cl_k}$ (type A),
        \item there is an edge from $\Set{Cl_1,Cl_2}$ to $\bot$ if and only if $(Cl_1\times
        Cl_2)\cap\Ec=\emptyset$\footnote{with a slight abuse of notation, we consider $Cl_1\times
        Cl_2$ to be a multiset rather than an ordered pair.} (type B),
        \item there are no other edges.
    \end{itemize}
    Additionally, we mark the nodes corresponding to
    $\Set{\Nc_{1,\chi}}_{\chi\in\Sigma\uin}$ as \airquotes{starting} nodes.
    
    The proof then roughly goes as follows: we show that an algorithm exists that builds
    $H^{Cl}_{\Pi}$ in finite time $[\bigstar 1]$, we show a relation between its
    longest hyperpath trees and the solvability horizon of $\Pi$ $[\bigstar 2]$, and finally show
    we can compute the longest hyperpath trees in finite time $[\bigstar 3]$.
    % I want to make these clickable with cref but leaving that for later.

    $[\bigstar 1]$ First, we initialise the graph with the node set and the edges of type
    (B), which can be done in time $O(2^{\card{\Sigma\uout}})$ by iterating over the
    powerset. To find the edges of type (A) we define a set of \emph{reached classes}
    which we initialise as the set of starting nodes
    $\Cc:=\Set{\Nc_{1,\chi}}_{\chi\in\Sigma\uin}$; if $\emptyset\in\Cc$, the problem is
    strongly unsolvable and the solvability horizon is $\infty$. We assume this is not the case.
    
    Then, we iterate over all the ornaments
    of height 1 (ie containing only the hook node and leaves) and max degree $\Delta$, over
    all elements of $\Sigma\uin$ as input labels to the hook node, and over all
    combinations of elements of $\Cc$ over the leaves. Note that there are finitely many
    such labelled trees.
    
    Now, we compute the class of each
    ornament as if it were an instance of $\Pi$ on the hook node, with the leaves
    accepting only and all of the labels in their input label. Every time we do this, we
    add the class to a set $\mathcal{U}$ and add an edge in $H^{Cl}_{\Pi}$ from the labels that appear on to the node corresponding
    to the class; if this edge already exists, we can skip this step. For convenience, if
    we are adding a new edge, we can store the tree we were considering as a label to it.

    At the end of this iteration, we check whether $\mathcal{U}\subseteq\Cc$; in this
    case, we stop. If $\mathcal{U}\nsubseteq\Cc$ we repeat the process by setting
    $\Cc':=\Cc\cup\mathcal{U}$. This means $\card{\Cc'}\geq\card{\Cc}+1$; since
    $\Cc',\Cc\subseteq\Pow(\Sigma\uout)$ the process has to terminate in at most
    $2^{2^{\card{\Sigma\uout}}}$ repetitions.

    To show that this algorithm is correct, we show that every possible ornament is encoded in
    the edges of type (A) by induction on the height $h$ (the maximum distance between the
    hook node and a leaf). This is vacuously true for $h=0$, meaning single leaves which
    do not have any sub-hanging tree; consider instead an ornament $H$ of height $h+1$. If
    every one of its sub-hanging trees (of height $\leq h$) was previously encoded,
    their classes were added $\Cc$ at some step. In the next step, we must have built an
    ornament of height 1 with each leaf corresponding to one of these sub-trees and added
    an edge encoding $H$ if it wasn't already present. Then $H$ is encoded, and by
    induction, so are all finite ornaments; we denote as $f$ the function mapping
    ornaments to their encoding edges.

    $[\bigstar 2]$ We claim that the unsolvability horizon of $\Pi$ corresponds to the
    maximum over the diameters of all hyperpath trees starting from the set $S$ of
    starting/leaf nodes and ending in $\bot$. More precisely, we claim for each such \emph{finite}
    hyperpath tree of diameter $d$ we can construct an unsolvable instance of diameter $d+1$ and for each
    unsolvable instance of diameter $d+1$ we can construct a hyperpath tree of diameter
    $d$.
    
    Let $T_{S,\bot}$ be a hyperpath tree from $S$ to $\bot$.
    Since $\bot\notin S$, there is a set $\Set{Cl_1,Cl_2}$ such that:
    \begin{itemize}
        \item there are hyperpath trees from $S$ to $Cl_1,Cl_2$, and
        \item $(Cl_1\times Cl_2)\cap\Ec=\emptyset$.
    \end{itemize}
    We traverse the hyperpath tree from $S$ to $Cl_1$; every time we traverse an hyperedge $h=(T,Cl)$,
    we replace each node corresponding to the class $Cl$ in the previous ornament with
    the ornament we labelled $h$ with. The result is an ornament $G_1$ of class $Cl_1$, of
    diameter equal to the hypertree depth $+1$; we repeat this procedure to get an ornament $G_2$ of
    class $Cl_2$. Then we join the two hooks of $G_1,G_2$ into a single edge $e$ to get a
    tree $T$; since $(Cl_1\times Cl_2)\cap\Ec=\emptyset$ there is no valid labelling for $e$
    and $T$ is an unsolvable instance of diameter equal to
    $\text{depth}(G_1)+\text{depth}(G_2)+1=\text{diam}(T_{S,\bot})-1$.

    Conversely, let $G$ be an unsolvable instance for $\Pi$ and let $e$ be any edge of $G$. Let
    $G_1,G_2$ be the two ornaments obtained by splitting $e$ in half; since no label
    assignment to $e$ would result in a solution, we have that
    $(\frCl(G_1)\times\frCl(G_2))\cap\Ec=\emptyset$ and there is a hyperedge from
    $\bot$ to $\Set{\frCl(G_1),\frCl(G_2)}$. From there, we can use the function $f$
    described above to map $G_1$ to its encoding edge, and so on recursively to find a
    hyperpath from the set of starting nodes to $\frCl(G_1)$ of length equal to
    $\text{depth}(G_1)-1$. By repeating this procedure on $G_2$ we get a hyperpath from $S$ to $\bot$ corresponding to a hyperpath tree of diameter
    $\text{depth}(G_1)-1+\text{depth}(G_2)-1+1=\text{diam}(G)+1$.

    Finally, note that the proof above applies to finite hyperpath trees. If any hyperpath
    from $S$ to $\bot$ contains a cycle, then we can find hyperpath trees of arbitrarily
    large finite depth; then we can find unsolvable instances of arbitrarily
    large depth, and $\Pi$ is strongly unsolvable (with a solvability horizon of $\infty$). Similarly, if no hyperpaths exist
    between $S$ and $\bot$, then no unsolvable instances exist, and the solvability
    horizon of $\Pi$ is zero. If at least one path exists and no paths contain cycles,
    there are finitely many paths; we can iterate over all of them to obtain their maximum
    diameter and the solvability horizon.\footnote{We are only concerned about finiteness
    here; a discussion of the complexity of finding the longest hyperpath can be found in \cite{thakurLinearConnectivityProblems2009}}
\end{proof}
\begin{thm}
Let $\Pi$ be a FSL problem. Then it is possible to decide
whether $\Pi$ is strongly unsolvable or weakly solvable and compute the solvability
horizon (if it exists). %in what time?
\end{thm}
\begin{proof}
    Let $\Pi=(\Sigma_out,\Nc,\Ec)$. We show that either $\Pi$ is strongly unsolvable or it has the same solvability
    horizon as a node-edge checkable problem.
    
    Define the problem $\Pi'$  
\end{proof}

\pagebreak
\printbibliography[ heading=bibintoc, title={Bibliography}]
\end{document}